#! /usr/bin/env node
/**
 *  @file       event-loop-timing.simple
 *
 *  Test timing of the event loop using a function that contains a delay, await, then another delay.
 *
 *  @author     Ryan Saweczko, ryansaweczko@kingsds.network
 *  @date       January 2022
 */


process.exitCode = 1;


const sandboxScripts = '../../libexec/sandbox/'

const files = [
  require.resolve(sandboxScripts + 'script-load-wrapper.js'),
  require.resolve(sandboxScripts + 'timer-classes.js'),
  require.resolve(sandboxScripts + 'event-loop-virtualization.js'),
]
const expectedOutputs = {
  'script-load-wrapper': false,
  'event-loop-virtualization': false,
  'cpuTime': false,
  'cpuTimeReason': 'Event not received.',
}

const loopDelay = 300;

function outputTests(message)
{
  if (message.value.script === 'script-load-wrapper')
    expectedOutputs['script-load-wrapper'] = true;
  if (message.value.script === 'event-loop-virtualization')
    expectedOutputs['event-loop-virtualization'] = true;
}


const realSetTimeout = setTimeout;
require('./globalPolyfillHelper').init(files, outputTests)

// For some reason, setting `self.setTimeout` in event-loop-virtualization
// doesn't clobber the supposedly-global `setTimeout` we are referencing in
// the `setTimeout`, below. This forces us to use the correct,
// worker-internal, virtual setTimeout in order to get our timing counted
setTimeout = self.setTimeout;

setTimeout(async () => {
  let time = Date.now();
  for (;Date.now()<time+loopDelay;){}
  await new Promise(r => setTimeout(r,1000));
  time = Date.now();
  for (;Date.now()<time+loopDelay;){}
},0)


realSetTimeout(() => {
  self.wrapScriptLoading({ scriptName: 'test' }, function test(protectedStorage) {
    const timeTaken = protectedStorage.timers.cpu.duration();
    // Give 5% buffer for allowable times - can drift a little due to timeout etc
    if (timeTaken*1.05 > loopDelay * 2 && timeTaken*.95 < loopDelay * 2)
      expectedOutputs.cpuTime = true;
    else
      expectedOutputs.cpuTimeReason = `Bad value returned for CPU time: ${timeTaken}, expected ${loopDelay * 2}Â±5%`;

    // If all of my expected outputs have been met, set the exit code to 0 since all was ok.
    if (Object.values(expectedOutputs).every((element) =>  element))
      process.exitCode = 0;
  })
}, 2000);



// Give more information in the event the test fails.
process.on('exit', (code) => {
  if (code !== 0)
    console.error(`Test Failed. End values for expected outputs was ${JSON.stringify(expectedOutputs)}`)
});